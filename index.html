<!DOCTYPE html>
<html lang="en">
<head>
  <title>Something Something Erlang</title>
  <meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="somethingsomethingerlang.css">
</head>
<body>
<h1>Intro</h1>
<p>
Just enough Erlang. For people who are curious about Erlang, but just want a quick intro.
</p>
<h1>Why Erlang?</h1>

<h4>Concurrency</h4>
<p>
You want more than one thing to happen at once, easily. Really easily. Laugh out loud easily. Also cheaply.
</p>
<h4>Supervision.</h4>
<p>
You know parts of your programs will crash because of random stuff, and you want to restart those parts automatically.
</p>
<h4>FP.</h4>
<p>
FP good.
</p>

 <h1>Why not?</h1>
 <p>
Mandatory periods, semi-colons, colons. Goofy syntax.
</p>
<p>
It's strange. It started out in Prolog. Prolog is weird (and Awesome!)
</p>
<p>
Stuff is named weird, like "OTP".
</p>
<p>
Erlang mostly lives in the Linux world.
</p>
<p>
The documentation can be a little tricky to navigate.
</p>

<h1>Execute Some Erlang</h1>

<p>
Often people want to start Erlang in the traditional way of writing a file, compiling it and running it.
Most of this tutorial can be followed in the Erlang shell ("REPL")
but let's get this part out of the way first.
</p>

<p>
First, install erlang: "sudo apt-get install erlang", "yum install erlang", "brew install erlang" or similar.
</p>

<p>
Open a file, create a module directive, an export directive, a function,
and save the file as &lt;module-name&gt;.erl.
</p>
<p class="code">
<span class="line">1</span><!--
--><span class="comment">%</span><!--
--><span class="comment">-</span><!--
--><span class="comment">file</span><!--
--><span class="comment">(</span><!--
--><span class="comment">hello_world.erl</span><!--
--><span class="comment">)</span><!--
--><span class="comment">.</span><!--
--><span class="blankline">newline</span><!--
--><span class="line">1</span><!--
--><span class="dash">-</span><!--
--><span class="module">module</span><!--
--><span class="paren">(</span><!--
--><span class="module-literal">hello_world</span><!--
--><span class="paren">)</span><!--
--><span class="period">.</span><!--
--><span class="line">2</span><!--
--><span class="blankline">newline</span><!--

--><span class="line">3</span><!--
--><span class="dash">-</span><!--
--><span class="export">export</span><!--
--><span class="paren">(</span><!--
--><span class="bracket">[</span><!--
--><span class="function">hello_world</span><!--
--><span class="slash">/</span><!--
--><span class="arity">0</span><!--
--><span class="bracket">]</span><!--
--><span class="paren">)</span><!--
--><span class="period">.</span><!--
--><span class="blankline">newline</span><!--
--><span class="line">5</span><!--
--><span class="line">5</span><!--
--><span class="function">hello_world</span><!--
--><span class="paren">(</span><!--
--><span class="paren">)</span><!--
--><span class="clause-arrow">-&gt;</span><!--
--><span class="newline">newline</span><!--
--><span class="line">6</span><!--
--><span class="line">6</span><!--
--><span class="indent">____</span><!--
--><span class="module-literal">io</span><!--
--><span class="colon">:</span><!--
--><span class="function">format</span><!--
--><span class="paren">(</span><!--
--><span class="line">6</span><!--
--><span class="double-quote">&quot;</span><!--
--><span class="string">hello world!</span><!--
--><span class="double-quote">&quot;</span><!--
--><span class="paren">)</span><!--
--><span class="period">.</span><!--
--><span class="newline">newline</span><!--
--><span class="line">7</span><!--
--><span class="blankline">newline</span>
</p>

<p>
Now in the shell run:
</p>

<p class="code">
erlc hello_world.erl
<span class="newline">newline</span>
erl -noshell -s hello_world hello_world  -s erlang halt
</p>

<p>
Voila! You've run an Erlang module from the command line.
This uses the erlang emulator--which normally we'd use to start a shell--to
instead run some Erlang code with the -s flag.
The -s flag can take a module and a function and run them.
First we run the hello_world:hello_world() function,
then the erlang:halt() function.
Clunky, no?
</p>

<p>
A more elegant way is to create an "escript": create a file called "hello_world"
and put in the following:
</p>

<p class="code"><!--
--><span class="comment">#!/usr/bin/env escript</span><!--
--><span class="blankline">blankline</span><!--
--><span class="function">main</span><!--
--><span class="paren">(</span><!--
--><span class="bracket">[</span><!--
--><span class="bracket">]</span><!--
--><span class="paren">)</span><!--
--><span class="clause-arrow">-></span><!--
--><span class="newline">newline</span><!--
--><span class="indent">____</span><!--
--><span class="module-literal">io</span><!--
--><span class="colon">:</span><!--
--><span class="function">format</span><!--
--><span class="paren">(</span><!--
--><span class="line">6</span><!--
--><span class="double-quote">&quot;</span><!--
--><span class="string">Hello world!</span><!--
--><span class="double-quote">&quot;</span><!--
--><span class="paren">)</span><!--
--><span class="period">.</span><!--
--><span class="blankline">blankline</span>
</p>

<p>
Make this an executable and run it.
You should see "Hello world!" as before.
This file is called an "escript".
The "shebang" at the front tells the shell how to run this file.
Namely, with the "escript" command.
</p>


<h1>Back to the Beginning.</h1>

<p>
Much of Erlang can be learned by tooling around in the Erlang shell.
To access the shell type "erl" in the OS shell.
The Erlang shell is called a "REPL", which is explained below.
Type the following code at the "1&gt;" prompt and hit enter.
</p>

<p class="code">
<span class="prompt">1&gt;</span><!--
--><span class="atom">something</span><!--
--><span class="comma">,</span><!--
--><span class="atom">something</span><!--
--><span class="comma">,</span><!--
--><span class="atom">erlang</span><!--
--><span class="comma">.</span><!--
--><span class="newline">newline</span><!--
--><span class="atom">erlang</span>
</p>

<p>
Sequences of expressions are separated by commas and end with a period.
The value of the last expression ('erlang') is returned.
</p>


<h1>REPL</h1>
<p>
A REPL (“repple”, like “ripple” with an e instead of an i) is a shell. A command-line interface.
</p>
<p>
Read-Evaluate-Print-Loop
</p>
<p>
It <em>READ</em>s what you’ve typed, like any command line.
<br>
It <em>EVAL</em>uates a complete statement, ending in a period. (Yes, like a sentence.)
<br>
It <em>PRINT</em>s out the result. (Everything has a result.)
<br>
It <em>LOOP</em>s back to reading what you’ve typed.
</p>

<p>
Each expression (explained soon) you evaluate has a number before a greater than sign:
</p>
<p class="code">
<span class="prompt">2&gt;</span><!--
--><span class="double-quote">"</span><!--
--><span class="string">My expression is priceless</span><!--
--><span class="double-quote">"</span><!--
--><span class="period">.</span><!--
--><span class="comment">%% "My expression is priceless" is a string</span><!--
--><span class="newline">newline</span><!--
-->"My expression is priceless"
</p>

<h1>Some Basics</h1>

<h2>Literals</h2>

<p>
Erlang does not have objects so all values are literals:
</p>

<p class="code"><!--
  --><span class="prompt">3&gt;</span><!--
  --><span class="integer">1</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->1
</p>
Integer.
<p class="code"><!--
  --><span class="newline">newline</span><!--
  --><span class="prompt">4&gt;</span><!--
  --><span class="float">2.3</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->2.3
</p>
float.
<p class="code"><!--
  --><span class="newline">newline</span><!--
  --><span class="prompt">5&gt;</span><!--
  --><span class="double-quote">&quot;</span><!--
  --><span class="string">abc</span><!--
  --><span class="double-quote">&quot;</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->"abc"
</p>
string.
<p class="code"><!--
  --><span class="newline">newline</span><!--
  --><span class="prompt">6&gt;</span><!--
  --><span class="atom">an_atom</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->an_atom
</p>
An atom, like a constant that evaluates to itself.
<p class="code"><!--
  --><span class="newline">newline</span><!--
  --><span class="prompt">7&gt;</span><!--
  --><span class="bracket">[</span><!--
  --><span class="integer">4</span><!--
  --><span class="comma">,</span><!--
  --><span class="float">5.0</span><!--
  --><span class="comma">,</span><!--
  --><span class="double-quote">&quot;</span><!--
  --><span class="string">def</span><!--
  --><span class="double-quote">&quot;</span><!--
  --><span class="bracket">]</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->[4, 5.0, "def"]
</p>
Heterogenous list.
<p class="code"><!--
  --><span class="newline">newline</span><!--
  --><span class="prompt">8&gt;</span><!--
  --><span class="brace">{</span><!--
  --><span class="integer">6000000</span><!--
  --><span class="comma">,</span><!--
  --><span class="bracket">[</span><!--
  --><span class="atom">another_atom</span><!--
  --><span class="bracket">]</span><!--
  --><span class="comma">,</span><!--
  --><span class="brace">{</span><!--
  --><span class="brace">}</span><!--
  --><span class="comma">,</span><!--
  --><span class="double-quote">&quot;</span><!--
  --><span class="string">ghi</span><!--
  --><span class="double-quote">&quot;</span><!--
  --><span class="brace">}</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->{60000000000000, [another_atom], {}, "ghi"}
</p>
Heterogenous 4-element tuple with a large int, single-element list of an atom,
an empty tuple and a list.


<h2>"Variable" "Assignment" (pattern matching)</h2>

<p class="code"><!--
  --><span class="prompt">9&gt;</span><!--
  --><span class="variable">A</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->* 1: variable 'A' is unbound
</p>

A hasn't been "assigned" to yet.

<p class="code"><!--
  --><span class="prompt">10&gt;</span><!--
  --><span class="variable">A</span><!--
  --><span class="equals">=</span><!--
  --><span class="integer">1</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->1<!--
  --><span class="newline">newline</span><!--
  --><span class="prompt">11&gt;</span><!--
  --><span class="variable">A</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->1
</p>

<p>
A has been matched to 1. It is now "assigned".
In order to match A, which is undefined, with 1, it assigned
1 to A.
</p>

<p class="code"><!--
  --><span class="prompt">12&gt;</span><!--
  --><span class="variable">A</span><!--
  --><span class="equals">=</span><!--
  --><span class="integer">2</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->** exception error: no match of right hand side value 2
</p>

<p>
A has already been assigned 1, so it cannot match 2.
</p>

<p class="code"><!--
  --><span class="prompt">13&gt;</span><!--
  --><span class="variable">A</span><!--
  --><span class="equals">=</span><!--
  --><span class="integer">1</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->1
</p>

<p>
A is 1, so it matches 1. A match returns the match.
</p>

<p class="code"><!--
  --><span class="prompt">14&gt;</span><!--
  --><span class="bracket">[</span><!--
  --><span class="brace">{</span><!--
  --><span class="atom">_</span><!--
  --><span class="comma">,</span><!--
  --><span class="variable">B</span><!--
  --><span class="brace">}</span><!--
  --><span class="bracket">]</span><!--
  --><span class="equals">=</span><!--
  --><span class="bracket">[</span><!--
  --><span class="brace">{</span><!--
  --><span class="integer">1</span><!--
  --><span class="comma">,</span><!--
  --><span class="integer">2</span><!--
  --><span class="brace">}</span><!--
  --><span class="bracket">]</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->[{1, 2}]
</p>

<p>
We can match within lists and tuples: 1 is matched to _ (wildcard) and ignored, 2 is matched to B.
The entire match is returned.
</p>

<p class="code"><!--
  --><span class="prompt">15&gt;</span><!--
  --><span class="variable">B</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->2
</p>

<p>
B now contains 2.
</p>


<h1>logic.</h1>


<p class="code"><!--
  --><span class="prompt">16&gt;</span><!--
  --><span class="integer">2</span><!--
  --><span class="greater-than">&gt;</span><!--
  --><span class="integer">1</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->true<!--
  --><span class="newline">newline</span><!--
  --><span class="prompt">17&gt;</span><!--
  --><span class="integer">1</span><!--
  --><span class="greater-than">&gt;</span><!--
  --><span class="integer">2</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->false
</p>

<p>
Simple boolean logic
</p>

<p class="code"><!--
  --><span class="newline">newline</span><!--
  --><span class="prompt">18&gt;</span><!--
  --><span class="double-quote">&quot;</span><!--
  --><span class="string">string</span><!--
  --><span class="double-quote">&quot;</span><!--
  --><span class="greater-than">&gt;</span><!--
  --><span class="atom">an_atom</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->true<!--
  --><span class="newline">newline</span><!--
  --><span class="prompt">19&gt;</span><!--
  --><span class="integer">2.0</span><!--
  --><span class="equals">==</span><!--
  --><span class="integer">2</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->true
</p>

<p>
Different types can be compared, with pre-defined precedence.
</p>

<p class="code"><!--
  --><span class="newline">newline</span><!--
  --><span class="prompt">20&gt;</span><!--
  --><span class="integer">2.0</span><!--
  --><span class="equals">=:=</span><!--
  --><span class="integer">2</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->false
</p>

<p>
Different types of literal can be compared for strict matching.
</p>


<h1>If</h1>

<p class="code"><!--
  --><span class="prompt">21&gt;</span><!--
  --><span class="if">if</span><!--
  --><span class="integer">1</span><!--
  --><span class="less-than">&gt;</span><!--
  --><span class="integer">0</span><!--
  --><span class="clause-arrow">-></span><!--
  --><span class="atom">yes</span><!--
  --><span class="semicolon">;</span><!--
  --><span class="atom">true</span><!--
  --><span class="clause-arrow">-&gt;</span><!--
  --><span class="atom">no</span><!--
  --><span class="period">.</span><!--
  --><span class="newline">newline</span><!--
  -->yes
</p>

<p>
Wait, what?
</p>
<p>
The arrow, <span class="code">-&gt;</span> basically means “then”,
the semi-colon means “else if”.
</p>
<p>
This reads as “If one is greater than zero, then evaluate
<span class="code"><span class="atom">yes</span></span>; otherwise if true then evaluate
<span class="code"><span class="atom">no</span></span>."
</p>
<p>
Everything you <em>do</em> (evaluate) in Erlang has a value. The last thing you evaluate in a sequence of things is the value of that sequence of things.
</p>

<p class="code"><!--
--><span class="prompt">22&gt;</span><!--
--><span class="integer">1</span><!--
--><span class="comma">,</span><!--
--><span class="integer">2</span><!--
--><span class="comma">,</span><!--
--><span class="integer">3</span><!--
--><span class="comma">,</span><!--
--><span class="integer">4</span><!--
--><span class="comma">,</span><!--
--><span class="integer">5</span><!--
--><span class="period">.</span><!--
--><span class="newline">newline</span><!--
-->5
</p>

<p class="code"><!--
--><span class="prompt">23&gt;</span><!--
--><span class="if">if</span><!--
--><span class="integer">1</span><!--
--><span class="greater-than">&gt;</span><!--
--><span class="integer">0</span><!--
--><span class="clause-arrow">-&gt;</span><!--
--><span class="integer">1</span><!--
--><span class="comma">,</span><!--
--><span class="integer">2</span><!--
--><span class="comma">,</span><!--
--><span class="integer">3</span><!--
--><span class="comma">,</span><!--
--><span class="integer">4</span><!--
--><span class="comma">,</span><!--
--><span class="integer">5</span><!--
--><span class="semicolon">;</span><!--
--><span class="integer">1</span><!--
--><span class="equals">=</span><!--
--><span class="integer">1</span><!--
--><span class="clause-arrow">-&gt;</span><!--
--><span class="atom">no</span><!--
--><span class="period">.</span><!--
--><span class="newline">newline</span><!--
-->5
</p>

What happens to
<span class="code"><span class="integer">1</span></span>,
<span class="code"><span class="integer">2</span></span>,
<span class="code"><span class="integer">3</span></span> and,
<span class="code"><span class="integer">4</span></span>?,
<p>
Nothing. You “did” them, which for numbers means doing nothing.
</p>

<p>
What about the
<p class="code"><!--
--><span class="integer">1</span><!--
--><span class="equals">=</span><!--
--><span class="integer">1</span><!--
--><span class="clause-arrow">-&gt;</span><!--
--><span class="atom">no</span><!--
--><span class="period">.</span>
</p>
<p>
  part?
</p>
<p>
The <span class="code"><span class="if">if</span></span>
statement always has to have a branch that works.
The <span class="code"><span class="if">if</span></span> will always return the result of whatever clause worked.
</p>

<h1>Case (aka switch, select)</h1>

<p class="code">
20&gt; case 1 of 2 -&gt; yes; _ -&gt; no end.
<br>
no
</p>

<p>
Yup, a lot like the <span class="code">if</span> statement. Same deal, but the case statement is more forgiving.
</p>
<p>
<span class="code">if</span> only lets you have a strict set of tests but case lets you use any expression.

<h1>Functions.</h1>

<p class="code">
21&gt; fun() -&gt; 1 end.
<br>
#Fun&lt;erl_eval.6.80484245&gt;
</p>
<p>
By golly, we've captured the evasive <span class="code">#Fun&lt;erl_blah blah&gt;</span> thingy!
</p>
<p>
From now on we'll print <span class="code">#Fun&lt;erl_eval.X.YZ&gt;</span>.
</p>
<p>
This is how erlang prints out a function.
</p>

<p>
Takes no arguments, returns 1. The end.
</p>

<p class="code">
22&gt; fun(1) -&gt; 1 end.
<br>
#Fun&lt;erl_eval.X.YZ&gt;
</p>
<p>
Takes one (HA!) argument, which must be the literal number 1 and returns 1.
</p>

<p class="code">
23&gt; fun(X) -&gt; 1 end.
<br>
#Fun&lt;erl_eval.X.YZ&gt;
</p>
<p>
Takes an argument, which we ignore, and returns 1.
</p>

<p class="code">
24&gt; fun(X) when X == 1 -&gt; 1 end.
<br>
#Fun&lt;erl_eval.X.YZ&gt;
</p>
<p>
Takes an argument, which we make sure is 1, and returns 1.
</p>

<p class="code">
25&gt; fun(X) when X &gt; 0 -&gt; positive;
<br>
25&gt; &nbsp;&nbsp; (X) when X &lt; 0 -&gt; negative;
<br>
25&gt; &nbsp;&nbsp; (0) -&gt; zero.
<br>
#Fun&lt;erl_eval.X.YZ&gt;
</p>
<p>
Three different “clauses” in one function that each “match” a different argument.
</p>
<p>
The “when” part is called a “guard”.
</p>
<p>
“if” statements only use guards.
</p>
<p>
Guards can only use "Built in Functions" or BIFs.
There is a <a href="http://erlang.org/doc/reference_manual/expressions.html#id84484">list</a>. I refer to it regularly.
</p>

<h1>Matchmaker, Matchmaker make me a match!</h1>

<p class="code">
26&gt; A.
<br>
* 1: variable ‘A’ is unbound.
</p>
<p>
Oh, so we have to “bind” variables.
</p>

<p class="code">
27&gt; A = 1.
<br>
1
</p>
<p>
Ah, so we assign a value.
</p>
<p>
NO! Bad!
</p>
<p>
We “match” the two values.
</p>
<p>
But A is “unbound”. How does it match 1?
</p>
<p>
Unbound variables are promiscuous. They will bind to the first thing they are matched with.
</p>
<p>
Okay fine, we assigned <span class="code">1</span> to <span class="code">A</span>, but we did it by matching.
</p>

<p class="code">
28&gt; A = 2.
<br>
** exception error: no match of right hand side value 2
</p>
<p>
What happened?
</p>
<p>
<span class="code">A</span> is no longer unbound. <span class="code">A</span> is bound to <span class="code">1</span>.
</p>
<p>
We tried to match <span class="code">A</span>, which is <span class="code">1</span>, with <span class="code">2</span>, … which is <span class="code">2</span>.
</p>

<p class="code">
29&gt; A = 1.
<br>
1
</p>
<p>
Yup. <span class="code">A</span> is <span class="code">1</span>.
The value of the expression matching <span class="code">A</span> to <span class="code">1</span> is also <span class="code">1</span>.
</p>

<p class="code">
30&gt; {A, B} = {1, 2}.
<br>
{1, 2}
<br>
31&gt; A.
<br>
1
<br>
32&gt; B.
<br>
2
</p>

<p>
We matched a tuple of two values to a tuple of two variables.
</p>
<p>
<span class="code">A</span> matched <span class="code">1</span>, because <span class="code">A</span> is already <span class="code">1</span>.
</p>
<p>
<span class="code">B</span> was unbound, so <span class="code">B</span> matched <span class="code">2</span> and is now bound to <span class="code">2</span>.
The result of the match is returned.

<p class="code">
33&gt; {X, [Y, {Z, 4}, “bob”], &lt;&lt;“Frank”&gt;&gt; 10, []} = {1, [b, {“Wham”, 4}, “bob”], &lt;&lt;“Frank”&gt;&gt; 10, []}.
<br>
{1, [b, {“Wham”, 4}, “bob”], &lt;&lt;“Frank”&gt;&gt;, 10, []}
</p>
<p>
Woah.
Yup, we just picked <span class="code">X</span>, <span class="code">Y</span> and <span class="code">Z</span> out of a lineup of data.
</p>
<p>
We “deconstructed” the frankendata to “pull out” some values.
</p>

<p class="code">
34&gt; X.
<br>
1
<br>
35&gt; Y.
<br>
b
<br>
36&gt; Z.
<br>
“Wham"
</p>
<h1>Files</h1>
<p>
Enough of this shell crap. I need a file I can send to Grandma.
</p>
<p>
Right, here's a sample "module" in a file named my_module.erl.
</p>
<p class="code">
-module(my_module).
<br><br>
-export([a/0]).
<br><br>
a() -&gt;
<br>
&nbsp;&nbsp;"Now we're talkin'!".
</p>
<p>
In your OS shell (e.g. bash) type <span class="code">erlc "my_module.erl"</span>
</p>
<p>
You should get <span class="code">my_module.beam</span>.
</p>
<p>
Now type <span class="code">erl</span> in the OS shell.
</p>
<p>
Now in the Erlang shell ...
</p>
<p class="code">
1&gt; l(my_module).
<br>
{module,my_module}
<br>
2&gt; my_module:a().
<br>
"Now we're talkin'!"
</p>
</body>
</html>
