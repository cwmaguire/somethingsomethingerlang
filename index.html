<!DOCTYPE html>
<html lang="en">
<head>
  <title>Something Something Erlang</title>
	<meta charset="utf-8">
  <style>
    .code {background: black; color: #D0D0D0; padding:5px; font-family:monospace;}
  </style>
</head>
<body>
<h1>Intro</h1>
<p>
Just enough Erlang. For people who are curious about Erlang, but just want a quick intro.
</p>
<p>
You're a smart cookie and you'll pay attention and notice things.
</p>
<h1>Why Erlang?</h1>

<h4>Concurrency</h4>
<p>
You want more than one thing to happen at once, easily. Really easily. Laugh out loud easily. Also cheaply.
</p>
<h4>Supervision.</h4>
<p>
You know parts of your programs will crash because of random stuff, and you want to restart those parts automatically.
</p>
<h4>FP.</h4>
<p>
<a href="fp.html">Functional programming</a> means<sup>*</sup> you know what all your variables hold and how they got that way.
</p>
<p>
Functional programming also means you can pass instructions around as if they were variables.
</p>
<p>
<sup>*</sup>Well, it means a lot.
</p>

 <h1>Why not?</h1>
 <p>
Mandatory periods, semi-colons, colons. Goofy syntax.
</p>
<p>
It's strange. It started out in Prolog. Prolog is weird (and Awesome!)
</p>
<p>
Stuff is named weird, like "OTP".
</p>
<p>
Erlang mostly lives in the Linux world.
</p>
<p>
The documentation can be a little tricky to navigate.
</p>

<h1>Getting started.</h1>
<p class="code">
1&gt; something, something, erlang.
<br>
erlang
</p>
<p>
Go install it. You can do it. You believe in you.
</p>

<h1>I’ve got a REPL. What now?</h1>
<p>
A REPL (“repple”, like “ripple” with an e instead of an i) is a shell. A command-line interface.
</p>
<p>
Read-Evaluate-Print-Loop
</p>
<p>
It <em>READ</em>s what you’ve typed, like any command line.
<br>
It <em>EVAL</em>uates a complete statement, ending in a period. (Yes, like a sentence.)
<br>
It <em>PRINT</em>s out the result. (Everything has a result.)
<br>
It <em>LOOP</em>s back to reading what you’ve typed.
</p>
<p>
Each expression you evaluate has a number before a greater than sign:
</p>
<p class="code">
512&gt; "My expression is priceless".
<br>
"My expression is pricesless"
</p>

<h1>What to type?</h1>
<p>
Statements.
Here are some to get us started.
</p>
<p class="code">
1&gt; 1.
<br>
1
</p>
<p>
This is an integer. A whole number.
</p>
<p class="code">
2&gt; 1 + 1.
<br>
2
</p>
<p>
This is addition.
</p>
<p class="code">
3&gt; 1.0.
<br>
1.0
</p>
<p>
This is a decimal number.
</p>
<p class="code">
4&gt; “I believe in myself.”.
<br>
"I believe in myself."
</p>
<p>
This is a list of numbers. It is a string. It is both.
</p>
<p class="code">
5&gt; a.
<br>
a
</p>
<p>
This is an atom. It is a constant with a value of a. What can you do with that? You might be surprised.
</p>
<p class="code">
6&gt; ‘a’.
<br>
a
</p>
<p>
This is an atom. It <em>looks</em> like a string. It is not.
</p>
<p class="code">
7&gt; &lt;&lt;“binary””&gt;&gt;.
</p>
<p>
This is a string, in binary. Actual bytes. Actual bits.
</p>
<p class="code">
8&gt; [this, “is”, a, &lt;&lt;“list”&gt;&gt;, of, 7, “elements”].
<br>
[this, “is”, a, &lt;&lt;“list”&gt;&gt;, of, 7, “elements”]
</p>
<p>
Lists can have different types of stuff.
</p>
<p class="code">
9&gt; [].
<br>
[]
</p>
<p>
Lists can be empty.
</p>
<p class="code">
10&gt; {“this”, is, ‘a’, &lt;&lt;“tuple”&gt;&gt; with, 7, elements}.
<br>
{“this”, is, ‘a’, &lt;&lt;“tuple”&gt;&gt; with, 7, elements}
</p>
<p>
Tuples can have different types of stuff.
</p>
<p class="code">
11&gt; {}.
<br>
{}
</p>
<p>
Tuples can be empty.
</p>
<p class="code">
12&gt; {[{[]}]}
<br>
{[{[]}]}
</p>
<p>
Tuple of list of tuple of empty list.
</p>
<p class="code">
13&gt; TheThing = 1.
<br>
1
</p>
<p>
<span class="code">TheThing</span> is a “variable.” It will never more vary. Eh?

<h1>Making logic.</h1>

<p class="code">
14&gt; 1 &gt; 0.
<br>
true
</p>
<p class="code">
15&gt; “I” &gt; you.
<br>
true
</p>

<p class="code">
16&gt; 1.0 &gt; 1.
<br>
false
</p>

<h1>What if ...</h1>

<p class="code">
17&gt; if 1 &gt; 0 -&gt; yes; true -&gt; no.
<br>
yes
</p>

<p>
Wait, what?
</p>
<p>
The arrow, <span class="code">-&gt;</span> basically means “then”, the semi-colon means “else if”.
</p>
<p>
This reads as “If one is greater than zero, then evaluate <span class="code">yes</span>; otherwise if true then evaluate <span class="code">no</span>."
</p>
<p>
Everything you <em>do</em> (evaluate) in Erlang has a value. The last thing you evaluate in a sequence of things is the value of that sequence of things.
</p>

<p class="code">
18&gt; 1, 2, 3, 4, 5.
<br>
5
</p>

<p class="code">
19&gt; if 1 &gt; 0 -&gt; 1, 2, 3, 4, 5; 1 = 1 -&gt; no.
<br>
5
</p>

What happens to <span class="code">1</span>, <span class="code">2</span>, <span class="code">3</span> and <span class="code">4</span>?
Nothing. You “did” them, which for numbers means doing nothing.

<p>
What about the <span class="code">true -&gt; no.</span> part?
</p>
<p>
The <span class="code">if</span> statement always has to have a branch that works. The <span class="code">if</span> will always return the result of whatever clause worked.
</p>

<h1>In the case of ...</h1>

<p class="code">
20&gt; case 1 of 2 -&gt; yes; _ -&gt; no end.
<br>
no
</p>

<p>
Yup, a lot like the <span class="code">if</span> statement. Same deal, but the case statement is more forgiving.
</p>
<p>
<span class="code">if</span> only lets you have a strict set of tests but case lets you use any expression.

<h1>Functions.</h1>

<p class="code">
21&gt; fun() -&gt; 1 end.
<br>
#Fun&lt;erl_eval.6.80484245&gt;
</p>
<p>
By golly, we've captured the evasive <span class="code">#Fun&lt;erl_blah blah&gt;</span> thingy!
</p>
<p>
From now on we'll print <span class="code">#Fun&lt;erl_eval.X.YZ&gt;</span>.
</p>
<p>
This is how erlang prints out a function.
</p>

<p>
Takes no arguments, returns 1. The end.
</p>

<p class="code">
22&gt; fun(1) -&gt; 1 end.
<br>
#Fun&lt;erl_eval.X.YZ&gt;
</p>
<p>
Takes one (HA!) argument, which must be the literal number 1 and returns 1.
</p>

<p class="code">
23&gt; fun(X) -&gt; 1 end.
<br>
#Fun&lt;erl_eval.X.YZ&gt;
</p>
<p>
Takes an argument, which we ignore, and returns 1.
</p>

<p class="code">
24&gt; fun(X) when X == 1 -&gt; 1 end.
<br>
#Fun&lt;erl_eval.X.YZ&gt;
</p>
<p>
Takes an argument, which we make sure is 1, and returns 1.
</p>

<p class="code">
25&gt; fun(X) when X &gt; 0 -&gt; positive;
<br>
25&gt; &nbsp;&nbsp; (X) when X &lt; 0 -&gt; negative;
<br>
25&gt; &nbsp;&nbsp; (0) -&gt; zero.
<br>
#Fun&lt;erl_eval.X.YZ&gt;
</p>
<p>
Three different “clauses” in one function that each “match” a different argument.
</p>
<p>
The “when” part is called a “guard”.
</p>
<p>
“if” statements only use guards.
</p>
<p>
Guards can only use "Built in Functions" or BIFs.
There is a <a href="http://erlang.org/doc/reference_manual/expressions.html#id84484">list</a>. I refer to it regularly.
</p>

<h1>Matchmaker, Matchmaker make me a match!</h1>

<p class="code">
26&gt; A.
<br>
* 1: variable ‘A’ is unbound.
</p>
<p>
Oh, so we have to “bind” variables.
</p>

<p class="code">
27&gt; A = 1.
<br>
1
</p>
<p>
Ah, so we assign a value.
</p>
<p>
NO! Bad!
</p>
<p>
We “match” the two values.
</p>
<p>
But A is “unbound”. How does it match 1?
</p>
<p>
Unbound variables are promiscuous. They will bind to the first thing they are matched with.
</p>
<p>
Okay fine, we assigned <span class="code">1</span> to <span class="code">A</span>, but we did it by matching.
</p>

<p class="code">
28&gt; A = 2.
<br>
** exception error: no match of right hand side value 2
</p>
<p>
What happened?
</p>
<p>
<span class="code">A</span> is no longer unbound. <span class="code">A</span> is bound to <span class="code">1</span>.
</p>
<p>
We tried to match <span class="code">A</span>, which is <span class="code">1</span>, with <span class="code">2</span>, … which is <span class="code">2</span>.
</p>

<p class="code">
29&gt; A = 1.
<br>
1
</p>
<p>
Yup. <span class="code">A</span> is <span class="code">1</span>.
The value of the expression matching <span class="code">A</span> to <span class="code">1</span> is also <span class="code">1</span>.
</p>

<p class="code">
30&gt; {A, B} = {1, 2}.
<br>
{1, 2}
<br>
31&gt; A.
<br>
1
<br>
32&gt; B.
<br>
2
</p>

<p>
We matched a tuple of two values to a tuple of two variables.
</p>
<p>
<span class="code">A</span> matched <span class="code">1</span>, because <span class="code">A</span> is already <span class="code">1</span>.
</p>
<p>
<span class="code">B</span> was unbound, so <span class="code">B</span> matched <span class="code">2</span> and is now bound to <span class="code">2</span>.
The result of the match is returned.

<p class="code">
33&gt; {X, [Y, {Z, 4}, “bob”], &lt;&lt;“Frank”&gt;&gt; 10, []} = {1, [b, {“Wham”, 4}, “bob”], &lt;&lt;“Frank”&gt;&gt; 10, []}.
<br>
{1, [b, {“Wham”, 4}, “bob”], &lt;&lt;“Frank”&gt;&gt;, 10, []}
</p>
<p>
Woah.
Yup, we just picked <span class="code">X</span>, <span class="code">Y</span> and <span class="code">Z</span> out of a lineup of data.
</p>
<p>
We “deconstructed” the frankendata to “pull out” some values.
</p>

<p class="code">
34&gt; X.
<br>
1
<br>
35&gt; Y.
<br>
b
<br>
36&gt; Z.
<br>
“Wham"
</p>
<h1>Files</h1>
<p>
Enough of this shell crap. I need a file I can send to Grandma.
</p>
<p>
Right, here's a sample "module" in a file named my_module.erl.
</p>
<p class="code">
-module(my_module).
<br><br>
-export([a/0]).
<br><br>
a() -&gt;
<br>
&nbsp;&nbsp;"Now we're talkin'!".
</p>
<p>
In your OS shell (e.g. bash) type <span class="code">erlc "my_module.erl"</span>
</p>
<p>
You should get <span class="code">my_module.beam</span>.
</p>
<p>
Now type <span class="code">erl</span> in the OS shell.
</p>
<p>
Now in the Erlang shell ...
</p>
<p class="code">
1&gt; l(my_module).
<br>
{module,my_module}
<br>
2&gt; my_module:a().
<br>
"Now we're talkin'!"
</p>
</body>
</html>
