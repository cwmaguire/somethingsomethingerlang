<!DOCTYPE html>
<html lang="en">
<head>
  <title>Something Something Erlang</title>
	<meta charset="utf-8">

  <style>
.code {background: black; color: #D0D0D0; padding:5px; font-family:monospace;}
  </style>
</head>
<body>
<h1>Why?</h1>

<p>
“Concurrency.” You want more than one thing to happen at once, easily. Really easily. Laugh out loud easily. Also cheaply.
</p>
<p>
“Supervision.” You know parts of your programs will crash because of random stuff, and you want to restart those parts automatically.
</p>
<p>
“FP.” Functional programming means you know what all your variables hold and how they got that way. Functional programming also means you can pass instructions around like variables.
     - functions
     - as opposed to what?
     - functions can be passed around
</p>

 <h1>Why not?</h1>
 <p>
Mandatory periods, semi-colons, colons.
</p>
<p>
Strange.
</p>
<p>
Erlang mostly lives in the Linux world.
</p>

<h1>Getting started.</h1>
<p class="code">
$&gt; something something erlang
</p>
<p>
Go install it. You can do it. You believe in you.
</p>

<h1>I’ve got a REPL. What now?</h1>
<p>
A REPL (“repple”, like “ripple” with an e instead of an i) is a shell.
Read-Evaluate-Print-Loop
</p>
<p>
It READs what you’ve typed, like any command line.
<br>
It EVALuates a complete statement, ending in a period. (Yes, like a sentence.)
<br>
It PRINTS out the result. (Everything has a result.)
<br>
It LOOPs back to reading what you’ve typed.
</p>
<p>
Each expression you evaluate has a number before a greater than sign:
</p>
<p class="code">
512&gt; "My expression is priceless".
<br>
"My expression is pricesless"
</p>

<h1>What to type?</h1>
<p>
Statements.
Here are some to get us started.
</p>
<p class="code">
1&gt; 1.
<br>
1
</p>
<p>
This is an integer. A whole number.
</p>
<p class="code">
2&gt; 1 + 1.
<br>
2
</p>
<p>
This is addition.
</p>
<p class="code">
3&gt; 1.0.
<br>
1.0
</p>
<p>
This is a decimal number.
</p>
<p class="code">
4&gt; “I believe in myself.”.
<br>
"I believe in myself."
</p>
<p>
This is a list of numbers. It is a string. It is both.
</p>
<p class="code">
5&gt; a.
<br>
a
</p>
<p>
This is an atom. It is a constant with a value of a. What can you do with that? You might be surprised.
</p>
<p class="code">
6&gt; ‘a’.
<br>
a
</p>
<p>
This is an atom. It _looks_ like a string. It is not.
</p>
<p class="code">
7&gt; &lt;&lt;“binary””&gt;&gt;.
</p>
<p>
This is a string, in binary. Actual bytes. Actual bits.
</p>
<p class="code">
8&gt; [this, “is”, a, &lt;&lt;“list”&gt;&gt;, of, 7, “elements”].
<br>
[this, “is”, a, &lt;&lt;“list”&gt;&gt;, of, 7, “elements”]
</p>
<p>
Lists can have different types of stuff.
</p>
<p class="code">
9&gt; [].
<br>
[]
</p>
<p>
Lists can be empty.
</p>
<p class="code">
10&gt; {“this”, is, ‘a’, &lt;&lt;“tuple”&gt;&gt; with, 7, elements}.
<br>
{“this”, is, ‘a’, &lt;&lt;“tuple”&gt;&gt; with, 7, elements}
</p>
<p>
Tuples can have different types of stuff.
</p>
<p class="code">
11&gt; {}.
<br>
{}
</p>
<p>
Tuples can be empty.
</p>
<p class="code">
12&gt; {[{[]}]}
<br>
{[{[]}]}
</p>
<p>
Tuple of list of tuple of empty list.
</p>
<p class="code">
13&gt; TheThing = 1.
<br>
1
</p>
<p>
TheThing is a “variable.” It will never more vary. Eh?

<h1>Making logic.</h1>

<p class="code">
14&gt; 1 &gt; 0.
<br>
true
</p>
<p class="code">
15&gt; “I” &gt; you.
<br>
true
</p>

<p class="code">
16&gt; 1.0 &gt; 1.
<br>
false
</p>

<h1>What if ...</h1>

<p class="code">
17&gt; if 1 &gt; 0 -&gt; yes; true -&gt; no.
<br>
yes
</p>

<p>
Wait, what?
</p>
<p>
The arrow, “-&gt; basically means “then”, the semi-colon means “else if”.
</p>
<p>
This reads as “If one is greater than zero, then do ‘yes’; otherwise if true then do ‘no’."
</p>
<p>
Wait, do?
</p>
<p>
Everything you do in Erlang has a value. The last thing you do in a sequence of things is the value of that sequence of things.
</p>

<p class="code">
18&gt; 1, 2, 3, 4, 5.
<br>
5
</p>

<p class="code">
19&gt; if 1 &gt; 0 -&gt; 1, 2, 3, 4, 5; 1 = 1 -&gt; no.
<br>
5
</p>

What happens to 1, 2, 3 and 4? Nothing. You “did” them, which for numbers means doing nothing.

<p>
What about the “true -&gt; no.” part?
The “if” statement always has to have a branch that works. The if will always return the result of whatever clause worked.
</p>

<h1>In the case of ...</h1>

<p class="code">
20&gt; case 1 of 2 -&gt; yes; _ -&gt; no end.
<br>
no
</p>

Yup, a lot like the “if” statement. Same deal, but the case statement is more forgiving. “if” only lets you have a strict set of tests but case lets you use any expression.

<h1>Functions.</h1>

<p class="code">
21&gt; fun() -&gt; 1 end.
</p>

<p>
Takes no arguments, returns 1. The end.
</p>

<p class="code">
22&gt; fun(1) -&gt; 1 end.
</p>
<p>
Takes one argument, which must be the literal number 1 and returns 1.
</p>

<p class="code">
23&gt; fun(X) -&gt; 1 end.
</p>
<p>
Takes an argument, which we ignore, and returns 1.
</p>

<p class="code">
24&gt; fun(X) when X == 1 -&gt; 1 end.
</p>
<p>
Takes an argument, which we make sure is 1, and returns 1.
</p>

<p class="code">
25&gt; fun(X) when X &gt; 0 -&gt; positive;
<br>
25&gt; &nbsp;&nbsp; (X) when X &lt; 0 -&gt; negative;
<br>
25&gt; &nbsp;&nbsp; (0) -&gt; zero.
<br>
#Fun&lt;erl_eval.6.80484245&gt;
</p>
<p>
By golly, we've captured the evasive #Fun&lt;erl_blah blah&gt; thingy!
This is how erlang prints out a function.
</p>
<p>
Three different “clauses” in one function that each “match” a different argument.
</p>
<p>
The “when” part is called a “guard”.
</p>
<p>
“if” statements only use guards.
</p>
<p>
Guards can only use "Built in Functions" or BIFs.
There is a <a href="http://erlang.org/doc/reference_manual/expressions.html#id84484">list</a>. I refer to it regularly.
</p>

<h1>Matchmaker, Matchmaker make me a match!</h1>

<p class="code">
26&gt; A.
<br>
* 1: variable ‘A’ is unbound.
</p>
<p>
Oh, so we have to “bind” variables.
</p>

<p class="code">
27&gt; A = 1.
</p>
<p>
Ah, so we assign a value.
</p>
<p>
NO! Bad!
</p>
<p>
We “match” the two values.
</p>
<p>
But A is “unbound”. How does it match 1?
</p>
<p>
Unbound variables are promiscuous. They will bind to the first thing they are matched with.
</p>
<p>
Okay fine, we assigned 1 to A, but we did it by matching.
</p>

<p class="code">
28&gt; A = 2.
<br>
** exception error: no match of right hand side value 2
</p>
<p>
What happened?
</p>
<p>
A is no longer unbound. A is bound to 1.
</p>
<p>
We tried to match A, which is 1, with 2, … which is 2.
</p>

<p class="code">
29&gt; A = 1.
<br>
1
</p>
<p>
Yup. <span class="code">A</span> is <span class="code">1</span>.
The value of the expression matching <span class="code">A</span> to <span class="code">1</span> is also <span class="code">1</span>.
</p>

<p class="code">
30&gt; {A, B} = {1, 2}.
<br>
{1, 2}
<br>
31&gt; A.
<br>
1
<br>
32&gt; B.
<br>
2
</p>

We matched a tuple of two values to a tuple of two variables.
A matched 1, because A is already 1.
B was unbound, so B matched 2 and is now bound to 2.
The result of the match is returned.

<p class="code">
33&gt; {X, [Y, {Z, 4}, “bob”], &lt;&lt;“Frank”&gt;&gt; 10, []} = {1, [b, {“Wham”, 4}, “bob”], &lt;&lt;“Frank”&gt;&gt; 10, []}.
<br>
{1, [b, {“Wham”, 4}, “bob”], &lt;&lt;“Frank”&gt;&gt;, 10, []}
</p>
<p>
Woah.
Yup, we just picked X, Y and Z out of a lineup of data.
</p>
<p>
We “deconstructed” the frankendata to “pull out” some values.
</p>

<p class="code">
34&gt; X.
<br>
1
<br>
35&gt; Y.
<br>
b
<br>
36&gt; Z.
<br>
“Wham"
</p>
</body>
</html>
